<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel PVP - PeerJS Multiplayer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', sans-serif; user-select: none; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Start Menu */
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #222; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .btn { background: #4CAF50; color: white; border: none; padding: 15px 30px; margin: 10px; font-size: 18px; cursor: pointer; border-radius: 5px; }
        .btn-red { background: #d9534f; }
        input { padding: 10px; font-size: 16px; text-align: center; width: 250px; margin: 5px; }
        #id-display { color: cyan; font-size: 20px; margin: 10px; font-weight: bold; background: #333; padding: 10px; border-radius: 5px; display: none; user-select: text; pointer-events: auto;}

        /* HUD */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid white; transform: translate(-50%, -50%); border-radius: 50%; }
        #health-bar-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 300px; height: 20px; background: #444; border: 2px solid black; }
        #health-bar { width: 100%; height: 100%; background: #ff3333; transition: width 0.2s; }
        #coords { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; }
        #chat-box { position: absolute; bottom: 60px; left: 10px; width: 300px; height: 150px; background: rgba(0,0,0,0.5); pointer-events: auto; display: flex; flex-direction: column; }
        #chat-log { flex-grow: 1; overflow-y: auto; color: white; font-size: 12px; padding: 5px; }
        #chat-input { width: 100%; box-sizing: border-box; }

        /* Mobile Controls */
        .mobile-ctrl { pointer-events: auto; display: none; position: absolute; touch-action: none; }
        #joystick-zone { bottom: 20px; left: 20px; width: 100px; height: 100px; background: rgba(255,255,255,0.1); border-radius: 50%; }
        #joystick-knob { width: 40px; height: 40px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 30px; left: 30px; pointer-events: none; }
        #btn-jump { bottom: 40px; right: 20px; width: 60px; height: 60px; background: rgba(0,255,0,0.3); border-radius: 50%; line-height: 60px; text-align: center; color: white; font-weight: bold; }
        #btn-attack { bottom: 120px; right: 20px; width: 50px; height: 50px; background: rgba(255,0,0,0.3); border-radius: 5px; line-height: 50px; text-align: center; color: white; }
    </style>
</head>
<body>

<div id="menu">
    <h1 style="color:white;">GITHUB PVP VOXEL</h1>
    <input type="text" id="username" placeholder="Dein Spielername" value="Player1">
    
    <div style="margin-top:20px; border-top: 1px solid #555; padding-top:20px;">
        <h3 style="color:#ddd">Multiplayer Setup</h3>
        <button class="btn" onclick="hostGame()">Spiel Hosten (Ich bin Server)</button>
        <div id="id-display">Deine ID wird generiert...</div>
        <br>
        <p style="color:white">ODER</p>
        <input type="text" id="host-id-input" placeholder="ID vom Host eingeben">
        <button class="btn btn-red" onclick="joinGame()">Spiel Beitreten</button>
    </div>
    
    <div style="margin-top: 20px;">
        <label style="color:white"><input type="checkbox" id="mobile-mode"> Mobile Mode?</label>
    </div>
</div>

<div id="ui" style="display:none;">
    <div id="crosshair"></div>
    <div id="coords">X:0 Y:0 Z:0</div>
    <div id="health-bar-container"><div id="health-bar"></div></div>
    
    <div id="chat-box">
        <div id="chat-log">Chat bereit...</div>
        <input type="text" id="chat-input" placeholder="Enter für Chat...">
    </div>

    <div id="joystick-zone" class="mobile-ctrl"><div id="joystick-knob"></div></div>
    <div id="btn-jump" class="mobile-ctrl">JUMP</div>
    <div id="btn-attack" class="mobile-ctrl">ATK</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/PointerLockControls.js"></script>
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

<script>
    // --- KONFIGURATION ---
    const RENDER_DISTANCE = 40; // Kleiner für Performance
    let MY_HP = 100;
    
    // --- GLOBALS ---
    let camera, scene, renderer, controls;
    let peer, conn; // PeerJS Objekte
    let connections = []; // Liste aller verbundenen Spieler (für Host)
    let isHost = false;
    let myId = null;
    
    // Game State
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    let raycaster = new THREE.Raycaster();
    
    let worldObjects = []; // Blöcke
    let otherPlayers = {}; // ObjektMap: { peerId: Mesh }

    // Materialien
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x55aa55 });
    const matDirt = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x666666 });
    const matDiamond = new THREE.MeshLambertMaterial({ color: 0x00ffff });
    const matEnemy = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Gegner Rot

    // --- MULTIPLAYER LOGIC (PeerJS) ---
    
    function initPeer() {
        // Erstelle eine zufällige ID
        const cleanId = document.getElementById('username').value.replace(/[^a-zA-Z0-9]/g, '') + Math.floor(Math.random()*1000);
        peer = new Peer(cleanId); 

        peer.on('open', (id) => {
            myId = id;
            console.log('Meine ID ist: ' + id);
            if(isHost) {
                document.getElementById('id-display').style.display = 'block';
                document.getElementById('id-display').innerText = "Deine ID: " + id;
                startGame();
            }
        });

        // Wenn jemand mich anruft (nur relevant für Host)
        peer.on('connection', (c) => {
            if(isHost) {
                setupConnection(c);
                chatLog("Neuer Spieler verbunden: " + c.peer);
            } else {
                // Client bekommt Verbindung zurück?
                c.on('data', handleData);
            }
        });
    }

    function hostGame() {
        isHost = true;
        initPeer();
    }

    function joinGame() {
        isHost = false;
        const hostId = document.getElementById('host-id-input').value;
        if(!hostId) return alert("Bitte Host ID eingeben!");
        
        initPeer();
        // Warte kurz bis eigene ID da ist, dann verbinden
        setTimeout(() => {
            conn = peer.connect(hostId);
            setupConnection(conn);
            startGame();
        }, 1000);
    }

    function setupConnection(connection) {
        if(isHost) connections.push(connection);
        else conn = connection;

        connection.on('open', () => {
            // Verbindung steht
             // Sende initial Name
             connection.send({ type: 'chat', msg: document.getElementById('username').value + " ist beigetreten." });
        });

        connection.on('data', (data) => handleData(data, connection.peer));
    }

    // Daten empfangen
    function handleData(data, senderId) {
        if (data.type === 'move') {
            updatePlayerPos(data.id || senderId, data.pos, data.rot);
            // Wenn ich Host bin, leite ich die Daten an alle anderen weiter (Relay)
            if(isHost) broadcastData(data, senderId);
        }
        else if (data.type === 'chat') {
            chatLog(data.msg);
            if(isHost) broadcastData(data, senderId);
        }
        else if (data.type === 'hit') {
            // Ich wurde getroffen?
            if(data.targetId === myId) {
                takeDamage(data.dmg);
            } else if (isHost) {
                broadcastData(data, senderId); // Weiterleiten an das Opfer
            }
        }
        else if (data.type === 'block') {
            // Welt Update (vereinfacht: Host entscheidet, Clients rendern)
            updateWorldBlock(data.pos, data.action);
            if(isHost) broadcastData(data, senderId);
        }
    }

    function broadcastData(data, excludeId) {
        connections.forEach(c => {
            if(c.peer !== excludeId) c.send(data);
        });
    }

    // Update Visuals anderer Spieler
    function updatePlayerPos(id, pos, rot) {
        if(id === myId) return; // Nicht mich selbst updaten

        if (!otherPlayers[id]) {
            // Neuer Spieler Mesh erstellen
            const geo = new THREE.BoxGeometry(10, 28, 10);
            const mesh = new THREE.Mesh(geo, matEnemy);
            mesh.userData = { isPlayer: true, peerId: id };
            scene.add(mesh);
            otherPlayers[id] = mesh;
            chatLog("Sehe Spieler: " + id);
        }
        
        const p = otherPlayers[id];
        p.position.set(pos.x, pos.y, pos.z);
        p.rotation.y = rot; // Nur Y Rotation übertragen
    }

    // --- GAME ENGINE ---

    function startGame() {
        document.getElementById('menu').style.display = 'none';
        document.getElementById('ui').style.display = 'block';

        const isMobile = document.getElementById('mobile-mode').checked;
        if(isMobile) {
            document.querySelectorAll('.mobile-ctrl').forEach(e => e.style.display = 'block');
            setupMobileControls();
        } else {
            setupPCControls();
        }

        init3D();
        animate();
        
        // Multiplayer Sync Loop (10x pro Sekunde)
        setInterval(() => {
            if(!camera) return;
            const myData = {
                type: 'move',
                id: myId,
                pos: { x: camera.position.x, y: camera.position.y - 10, z: camera.position.z }, // -10 weil Kamera im Kopf
                rot: camera.rotation.y
            };
            
            if(isHost) broadcastData(myData, null);
            else if(conn && conn.open) conn.send(myData);
            
        }, 100);
    }

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 30, 0);

        // Licht
        const ambLight = new THREE.AmbientLight(0xcccccc);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        renderer = new THREE.WebGLRenderer({ antialias: false }); // Performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        generateWorld();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function generateWorld() {
        // Boden Generieren
        const geo = new THREE.BoxGeometry(20, 20, 20);
        
        for(let x = -10; x < 10; x++) {
            for(let z = -10; z < 10; z++) {
                // Gras
                createBlock(x*20, 0, z*20, matGrass);
                // Stein darunter
                createBlock(x*20, -20, z*20, matStone);
                // Zufalls Baum
                if(Math.random() > 0.9) createTree(x*20, 20, z*20);
                // Diamant
                if(Math.random() > 0.95) createBlock(x*20, 20, z*20, matDiamond);
            }
        }
        // Bedrock Wand
        createBlock(200, 20, 0, matStone);
    }

    function createBlock(x, y, z, mat) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(20,20,20), mat);
        mesh.position.set(x,y,z);
        scene.add(mesh);
        worldObjects.push(mesh);
    }

    function updateWorldBlock(pos, action) {
        // Sehr simpel: Sucht Block an Position und entfernt ihn
        // Echte Voxel Engine bräuchte ein Grid-Array, hier Brute-Force für Demo
        if(action === 'break') {
            for(let i=0; i<worldObjects.length; i++) {
                const b = worldObjects[i];
                if(b.position.x === pos.x && b.position.y === pos.y && b.position.z === pos.z) {
                    scene.remove(b);
                    worldObjects.splice(i, 1);
                    break;
                }
            }
        }
    }

    function createTree(x, y, z) {
        const trunk = new THREE.MeshLambertMaterial({color: 0x5D4037});
        const leaf = new THREE.MeshLambertMaterial({color: 0x2E7D32});
        createBlock(x, y, z, trunk);
        createBlock(x, y+20, z, trunk);
        createBlock(x, y+40, z, leaf);
        createBlock(x+20, y+20, z, leaf);
        createBlock(x-20, y+20, z, leaf);
    }

    // --- CONTROLS & PHYSICS ---
    function setupPCControls() {
        controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(camera.position.y <= 25) velocity.y = 200; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });
        document.addEventListener('mousedown', onAttackOrBuild);
    }

    function setupMobileControls() {
        let touchStartX = 0, touchStartY = 0;
        const zone = document.getElementById('joystick-zone');
        const stick = document.getElementById('joystick-knob');

        zone.addEventListener('touchmove', (e) => {
            const t = e.touches[0];
            const dx = t.clientX - zone.getBoundingClientRect().left - 50;
            const dy = t.clientY - zone.getBoundingClientRect().top - 50;
            stick.style.transform = `translate(${dx}px, ${dy}px)`;
            
            moveForward = dy < -10;
            moveBackward = dy > 10;
            moveLeft = dx < -10;
            moveRight = dx > 10;
        });
        
        zone.addEventListener('touchend', () => {
            stick.style.transform = `translate(0px,0px)`;
            moveForward = moveBackward = moveLeft = moveRight = false;
        });

        // Rechte Seite Bildschirm = Umsehen
        let lastX = 0;
        document.addEventListener('touchmove', (e) => {
            if(e.touches[0].clientX > window.innerWidth/2) {
                const delta = e.touches[0].clientX - lastX;
                camera.rotation.y -= delta * 0.005;
                lastX = e.touches[0].clientX;
            }
        });
        document.addEventListener('touchstart', (e) => lastX = e.touches[0].clientX);

        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
             e.preventDefault(); if(camera.position.y <= 25) velocity.y = 200;
        });
        document.getElementById('btn-attack').addEventListener('touchstart', (e) => {
             e.preventDefault(); onAttackOrBuild({button:0});
        });
    }

    // --- INTERACTION ---
    function onAttackOrBuild(e) {
        if(!controls.isLocked && !document.getElementById('mobile-mode').checked) return;

        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        
        // Prüfe auf Spieler Treffer (PVP)
        const playerMeshes = Object.values(otherPlayers);
        const hitPlayer = raycaster.intersectObjects(playerMeshes);
        
        if(hitPlayer.length > 0 && hitPlayer[0].distance < 40) {
            // Treffer!
            const targetMesh = hitPlayer[0].object;
            const targetId = targetMesh.userData.peerId;
            chatLog("Du hast jemanden geschlagen!");
            
            const dmgData = { type: 'hit', targetId: targetId, dmg: 10 };
            if(isHost) broadcastData(dmgData, null);
            else conn.send(dmgData);
            return;
        }

        // Wenn kein Spieler, prüfe Block (Abbauen)
        const hitBlock = raycaster.intersectObjects(worldObjects);
        if(hitBlock.length > 0 && hitBlock[0].distance < 50 && e.button === 0) {
            const obj = hitBlock[0].object;
            scene.remove(obj);
            worldObjects.splice(worldObjects.indexOf(obj), 1);
            
            // Netzwerk Update
            const blockData = { type: 'block', pos: obj.position, action: 'break' };
            if(isHost) broadcastData(blockData, null);
            else conn.send(blockData);
        }
    }

    function takeDamage(amount) {
        MY_HP -= amount;
        document.getElementById('health-bar').style.width = MY_HP + "%";
        chatLog("AUA! Schaden erhalten. HP: " + MY_HP);
        
        if(MY_HP <= 0) {
            MY_HP = 100;
            camera.position.set(0, 30, 0); // Respawn
            chatLog("Du bist gestorben!");
            document.getElementById('health-bar').style.width = "100%";
        }
    }

    function chatLog(msg) {
        const log = document.getElementById('chat-log');
        const d = document.createElement('div');
        d.innerText = msg;
        log.appendChild(d);
        log.scrollTop = log.scrollHeight;
    }
    
    // Chat Input
    document.getElementById('chat-input').addEventListener('keydown', (e) => {
        if(e.key === 'Enter') {
            const msg = document.getElementById('username').value + ": " + e.target.value;
            chatLog(msg);
            const data = { type: 'chat', msg: msg };
            if(isHost) broadcastData(data, null);
            else if(conn) conn.send(data);
            e.target.value = '';
        }
    });

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 50.0 * delta; // Gravity

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

        if(controls && controls.isLocked) {
             controls.moveRight(-velocity.x * delta);
             controls.moveForward(-velocity.z * delta);
        } else if (document.getElementById('mobile-mode').checked) {
             // Einfache Mobile Bewegung
             camera.translateX(-velocity.x * delta);
             camera.translateZ(-velocity.z * delta);
        }
        
        camera.position.y += (velocity.y * delta);

        if (camera.position.y < 20) {
            velocity.y = 0;
            camera.position.y = 20;
        }
        
        // Coords
        document.getElementById('coords').innerText = `X:${Math.round(camera.position.x)} Y:${Math.round(camera.position.y)} Z:${Math.round(camera.position.z)}`;

        renderer.render(scene, camera);
    }

</script>
</body>
</html>
